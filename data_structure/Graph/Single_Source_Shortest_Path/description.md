## Dijkstra

**加权图中查找一个起始节点到其他每一个可到达节点的最短路径，适用于权重为非负数的有向图或无向图**

算法步骤：

1.创建一个表示图中点到起始点距离的字典，全部点初始化为无穷大，起始点到起始点距离为0

2.创建一个表示已经访问的节点的集合

3.从未访问过的节点中寻找出当前距离起始节点最近（即未被访问的节点的对应边的边权`w`和当前已经存储的路径中可连接到这条边的最短路径`d`），标记该点为已访问，并更新到该点的距离为`dis[i]=d+w`

4.已经访问过的节点，若当前已存储的路径中存在另外的可到达该节点的路径（即在访问过之后又找到新路径访问到该节点），比较`dis[i]`和`d+w`的大小，并更新`dis[i]`

重复3、4步直到所有节点都被访问

时间复杂度：对于不使用堆优化的Dijkstra，每一次都需要遍历所有节点来找到当前未访问过的可到达节点和访问过的可更新节点，时间复杂度`O(N^2)`

对于使用优先队列优化的，找到最短路最小节点的复杂度`O(log m)`，每个节点至少被遍历一遍，总复杂度`O((n+m)log m)`



## Floyd

**用于加权图中寻找每一对可到达顶点之间的最短路**

算法步骤：

（默认无法到达的点之间边权为无穷大）`f[u][v]`表示点对`(u,v)`之间当前的最短路，遍历所有顶点，判断是否存在`w`，使得`f[u][v]>f[u][w]+f[w][v]`，存在则更新

时间复杂度：`O(N^3)`



## 无权最短路

可认为是所有边权为1的加权最短路，BFS求解，`O(n+m)`



